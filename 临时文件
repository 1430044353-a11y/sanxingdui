<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>三星堆全息 AR - 粒子点云交互版</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r160/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #050505; overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; }
        #video-container { position: fixed; inset: 0; z-index: 1; }
        video#webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); filter: brightness(0.3) contrast(1.5); }
        canvas#three-canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 2; pointer-events: none; }
        
        .ui-overlay { position: absolute; top: 40px; left: 40px; color: #d4af37; z-index: 10; pointer-events: none; }
        
        #ai-bubble { 
            position: fixed; bottom: 120px; right: 40px; width: 300px; 
            background: rgba(15, 10, 0, 0.85); border: 1px solid #d4af37; 
            padding: 20px; color: #fff; border-radius: 15px; 
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.2);
            opacity: 0; transition: all 0.5s ease; z-index: 20;
            backdrop-filter: blur(15px); pointer-events: none;
        }
        #ai-bubble.active { opacity: 1; transform: translateY(-10px); }
        
        #start-prompt { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #d4af37; cursor: pointer; text-align: center; }
        
        .loading-ui { margin-top: 20px; display: none; }
        .bar { width: 200px; height: 1px; background: rgba(212,175,55,0.2); position: relative; overflow: hidden; }
        .progress { width: 0%; height: 100%; background: #d4af37; transition: width 0.3s; }
    </style>
</head>
<body>

<div id="start-prompt">
    <div class="text-3xl font-black mb-4 tracking-[0.5em] text-white">数字考古粒子系统</div>
    <div class="text-xs opacity-50 mb-8 tracking-widest">DIGITAL HERITAGE POINT-CLOUD V1.1</div>
    <div class="px-10 py-4 border border-[#d4af37] text-[#d4af37] hover:bg-[#d4af37] hover:text-black transition-all font-bold">同步全息链路</div>
    <div id="loading-container" class="loading-ui">
        <div class="bar"><div id="load-progress" class="progress"></div></div>
        <div class="text-[10px] mt-2 opacity-50">正在重构粒子云...</div>
    </div>
</div>

<div id="ai-bubble">
    <div class="text-[10px] text-[#d4af37] mb-2 uppercase tracking-widest font-bold">AI Oracle</div>
    <div id="ai-content" class="text-sm leading-relaxed opacity-90">等待语音指令...</div>
</div>

<div class="ui-overlay">
    <div class="mb-2 text-[10px] tracking-[0.5em] opacity-40 uppercase">Particle Archeology Engine</div>
    <h1 id="artifact-title" class="text-5xl font-black mb-1 text-white">系统准备中</h1>
    <div id="artifact-id" class="text-xs font-mono tracking-widest opacity-60 uppercase">SCAN_MODE: FLUID_ROTATION</div>
</div>

<div id="video-container">
    <video id="webcam" playsinline autoplay></video>
</div>

<canvas id="three-canvas"></canvas>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

const apiKey = ""; 

const mockArtifacts = [
    { title: "黄金面具", id: "SXD-CLOUD-01", path: "https://raw.githubusercontent.com/1430044353-a11y/sanxingdui/main/1-v1.glb" },
    { title: "青铜神坛", id: "SXD-CLOUD-02", path: "2.glb" },
    { title: "数字文物 03", id: "SXD-CLOUD-03", path: "3.glb" }
];

let currentIdx = -1;
let scene, camera, renderer, artifactGroup, particleMaterial;
let hands, videoElement, recognition;
let isInitialized = false;
let isAIThinking = false;

// 交互变量增强
let lastHandPos = { x: 0, y: 0 };
let rotationVelocity = { x: 0, y: 0 };
let isTracking = false;

let lastPinchState = false;
let lastPinchTime = 0;
const PINCH_THRESHOLD = 0.04;
const DOUBLE_TAP_GAP = 500;

async function askAI(query) {
    if (isAIThinking || !apiKey) return;
    isAIThinking = true;
    const bubble = document.getElementById('ai-bubble');
    const content = document.getElementById('ai-content');
    if (bubble) bubble.classList.add('active');
    if (content) content.innerText = "分析中...";

    try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ parts: [{ text: query }] }],
                systemInstruction: { parts: [{ text: "你是一个资深考古专家，正对着三星堆点云模型进行讲解。请一句话简短回答。" }] }
            })
        });
        const data = await response.json();
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "信号波段异常。";
        if (content) content.innerText = text;
        setTimeout(() => { if(!isAIThinking && bubble) bubble.classList.remove('active'); }, 8000);
    } catch (e) {
        if (content) content.innerText = "通讯中断。";
    } finally {
        isAIThinking = false;
    }
}

function switchModel() {
    if (!artifactGroup) return;
    currentIdx = (currentIdx + 1) % mockArtifacts.length;
    const data = mockArtifacts[currentIdx];
    const loader = new GLTFLoader();

    const safePath = data.path.replace(/^\.\//, "");

    loader.load(safePath, (gltf) => {
        while(artifactGroup.children.length > 0) artifactGroup.remove(artifactGroup.children[0]);
        
        let targetMesh = null;
        gltf.scene.traverse((child) => {
            if (child.isMesh) targetMesh = child;
        });

        if (targetMesh) {
            const geometry = targetMesh.geometry;
            const points = new THREE.Points(geometry, particleMaterial);

            const box = new THREE.Box3().setFromObject(points);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 5.5 / (maxDim || 1);

            points.scale.set(scale, scale, scale);
            points.position.sub(center.multiplyScalar(scale));
            
            artifactGroup.add(points);
            
            const titleEl = document.getElementById('artifact-title');
            const idEl = document.getElementById('artifact-id');
            if (titleEl) titleEl.innerText = data.title;
            if (idEl) idEl.innerText = data.id;
        }
    }, (xhr) => {
        const progressBar = document.getElementById('load-progress');
        if (progressBar && xhr.total > 0) {
            const p = (xhr.loaded / xhr.total * 100);
            progressBar.style.width = p + '%';
        }
    }, (error) => {
        console.error("加载失败:", safePath, error);
    });
}

async function initSystem() {
    if (isInitialized) return;
    
    const loadingUI = document.getElementById('loading-container');
    if (loadingUI) loadingUI.style.display = 'block';

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 12;

    renderer = new THREE.WebGLRenderer({ 
        canvas: document.getElementById('three-canvas'), 
        antialias: true, alpha: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    particleMaterial = new THREE.PointsMaterial({
        color: 0xd4af37,
        size: 0.015,
        transparent: true,
        opacity: 0.7,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    artifactGroup = new THREE.Group();
    scene.add(artifactGroup);

    switchModel();

    videoElement = document.getElementById('webcam');
    
    try {
        const handsObj = new window.Hands({ 
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` 
        });
        handsObj.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.8 });
        handsObj.onResults(onHandResults);
        
        const cam = new window.Camera(videoElement, { 
            onFrame: async () => { await handsObj.send({image: videoElement}); }, 
            width: 1280, height: 720 
        });
        cam.start();
    } catch (e) {
        console.warn("MediaPipe Camera failed.");
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (SpeechRecognition) {
        recognition = new SpeechRecognition();
        recognition.lang = 'zh-CN';
        recognition.continuous = true;
        recognition.onresult = (e) => {
            const t = e.results[e.results.length-1][0].transcript;
            if(t.trim().length > 1) askAI(t);
        };
        recognition.start();
    }

    setTimeout(() => {
        const sp = document.getElementById('start-prompt');
        if (sp) {
            sp.style.opacity = '0';
            setTimeout(() => sp.remove(), 600);
        }
    }, 1500);

    isInitialized = true;
    animate();
}

function onHandResults(results) {
    if (!isInitialized || !artifactGroup) return;
    
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const h1 = results.multiHandLandmarks[0];
        const currentFinger = h1[8]; // 食指指尖

        if (!isTracking) {
            lastHandPos = { x: currentFinger.x, y: currentFinger.y };
            isTracking = true;
        }

        // --- 改进后的相对旋转逻辑 ---
        // 计算手指移动位移 (Delta)
        const dx = (currentFinger.x - lastHandPos.x) * 10;
        const dy = (currentFinger.y - lastHandPos.y) * 10;

        // 更新旋转速度 (带一点平滑)
        rotationVelocity.y = dx * 0.15;
        rotationVelocity.x = dy * 0.15;

        lastHandPos = { x: currentFinger.x, y: currentFinger.y };

        // 双手缩放逻辑保持
        if (results.multiHandLandmarks.length === 2) {
            const h2 = results.multiHandLandmarks[1];
            const dist = Math.sqrt(Math.pow(h1[8].x - h2[8].x, 2) + Math.pow(h1[8].y - h2[8].y, 2));
            const s = THREE.MathUtils.mapLinear(dist, 0.1, 0.7, 0.4, 3.0);
            artifactGroup.scale.lerp(new THREE.Vector3(s, s, s), 0.1);
        }

        // 捏合双击逻辑
        const distPinch = Math.sqrt(Math.pow(h1[4].x - h1[8].x, 2) + Math.pow(h1[4].y - h1[8].y, 2));
        const isPinching = distPinch < PINCH_THRESHOLD;
        const now = Date.now();
        if (isPinching && !lastPinchState) {
            if (now - lastPinchTime < DOUBLE_TAP_GAP) {
                switchModel();
                lastPinchTime = 0;
            } else {
                lastPinchTime = now;
            }
        }
        lastPinchState = isPinching;
    } else {
        isTracking = false;
        // 手部丢失时，速度缓慢衰减（惯性效果在 animate 中处理）
    }
}

function animate() {
    if (!isInitialized) return;
    requestAnimationFrame(animate);
    
    if (artifactGroup) {
        // 应用旋转速度
        artifactGroup.rotation.y += rotationVelocity.y;
        artifactGroup.rotation.x += rotationVelocity.x;

        // 旋转惯性衰减 (Damping)
        // 0.95 是摩擦系数，数字越大惯性越久
        rotationVelocity.y *= 0.95;
        rotationVelocity.x *= 0.95;

        // 基础自转 (仅当用户不操作时缓慢旋转，保持灵动感)
        if (Math.abs(rotationVelocity.y) < 0.001) {
            artifactGroup.rotation.y += 0.002;
        }
    }
    
    renderer.render(scene, camera);
}

const startBtn = document.getElementById('start-prompt');
if (startBtn) startBtn.addEventListener('click', initSystem);

window.addEventListener('resize', () => {
    if (!camera || !renderer) return;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
